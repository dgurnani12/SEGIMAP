use parser::{
    All,
    Attribute,
    Body,
    BodyStructure,
    Command,
    Envelope,
    Fetch,
    Flags,
    Header,
    InternalDate,
    Number,
    Plain,
    Range,
    RFC822,
    SequenceItem,
    Size,
    Text,
    UID
};

/* FETCH command rules */

/*#[export]
fetch
    = "FETCH" SP sequence_set SP ("ALL" / "FULL" / "FAST" / fetch_att / "(" fetch_att (SP fetch_att)* ")") */
#[export]
fetch -> Command
    = "FETCH" SP set:sequence_set SP attrs:(
      "ALL" { vec![Flags, InternalDate, RFC822(Size), Envelope] }
    / "FULL" { vec![Flags, InternalDate, RFC822(Size), Envelope, Body] }
    / "FAST" { vec![Flags, InternalDate, RFC822(Size)] }
    / attr:fetch_att { vec![attr] })
    { Command::new(Fetch, set, attrs) }

fetch_att -> Attribute
    = "ENVELOPE" { Envelope }
    / "FLAGS" { Flags }
    / "INTERNALDATE" { InternalDate }
    / "RFC822" sub_attr:(".HEADER" { Header } / ".SIZE" { Size } / ".TEXT" { Text })? { RFC822(sub_attr.unwrap_or(Plain)) }
    / "BODY" sub_attr:("STRUCTURE" { BodyStructure })? { sub_attr.unwrap_or(Body) }
    / "UID" { UID }
/*    / "BODY" section ("<" number "." nz_number ">")? { () } */
/*    / "BODY.PEEK" section ("<" number "." nz_number ">")? { () } */

section
    = "[" section_spec? "]"

section_spec
    = section_msgtext / (section_part ("." section_text)?) { () }

section_msgtext
    = "HEADER" / "HEADER.FIELDS" ".NOT"? SP header_list
    / "TEXT"
    /* top-level or MESSAGE/RFC822 part */

header_list
    = "(" header_fld_name (SP header_fld_name)* ")"

header_fld_name
    = astring

section_part
    = nz_number ("." nz_number)*
    /* body part nesting */

section_text
    = section_msgtext / "MIME"
    /* text other than actual body part (headers, etc.) */

astring
    = ASTRING_CHAR+ / string

ASTRING_CHAR
    = ATOM_CHAR / resp_specials

ATOM_CHAR
    = (!atom_specials CHAR)
    /* any CHAR except atom_specials */

atom_specials
    = "(" / ")" / "{" / SP / CTL / list_wildcards
    / quoted_specials / resp_specials

CTL
    = [\x00-\x1F] / [\x7F]
    /* control characters */

list_wildcards
    = "%" / "*"

quoted_specials
    = DQUOTE / "\\"

resp_specials
    = "]"

string
    = quoted / literal

quoted
    = DQUOTE QUOTED_CHAR* DQUOTE

literal
    = "{" number "}" CRLF CHAR8*

QUOTED_CHAR
    = (!quoted_specials TEXT_CHAR)
    / "\\" quoted_specials
    /* any TEXT_CHAR except quoted_specials */

TEXT_CHAR
    = (!eolChar CHAR)
    /* any CHAR except CR and LF */

/* SequenceItem and set rules */

#[export]
sequence_set -> Vec<SequenceItem>
    = a:(seq_range / seq_number) b:("," sequence_set)*
    {
        let mut seq = vec![a];
        for set in b.into_iter() {
            for elem in set.into_iter() {
                seq.push(elem);
            }
        };
        seq
    }

seq_range -> SequenceItem
    = a:seq_number ":" b:seq_number
    { Range(box a, box b) }

seq_number -> SequenceItem
    = (num:nz_number { Number(num) }) / (all:"*" { All })

/* RFC 3501 BOILERPLATE */

number -> uint
    = u:(DIGIT+ { from_str::<uint>(match_str).unwrap() })
    { u }
    /*
     * unsigned 32-bit integer
     * (0 <= n < 4,294,967,296)
     */

nz_number -> uint
    = u:(digit_nz DIGIT* { from_str::<uint>(match_str).unwrap() })
    { u }
    /*
     * non-zero unsigned 32-bit integer
     * (0 < n < 4,294,967,296)
     */

digit_nz
    = [1-9]

DIGIT
    = [0-9]

CHAR
    = .
    /* any ASCII char */

CHAR8
    = (![\x00] CHAR)
    /* any octet except NUL, \x00 */

DQUOTE
    = "\""

SP
    = whitespace

CRLF
    = eol

/* PEG boilerplate from kevinmehall/rust-peg follows */

__ = (whitespace / eol / comment)*

/* Modeled after ECMA-262, 5th ed., 7.4. */
comment
    = singleLineComment
    / multiLineComment

singleLineComment
    = "//" (!eolChar .)*

multiLineComment
    = "/*" (!"*/" .)* "*/"

/* Modeled after ECMA-262, 5th ed., 7.3. */
eol
    = "\n"
    / "\r\n"
    / "\r"
    / "\u2028"
    / "\u2029"

eolChar
    = [\n\r\u2028\u2029]
    /* Modeled after ECMA-262, 5th ed., 7.2. */

whitespace
    = [ \t\u00A0\uFEFF\u1680\u180E\u2000-\u200A\u202F\u205F\u3000] // \v\f removed
