use std::ascii::AsciiExt;

use command::command::{
    Attribute,
    BodySectionType,
    Command,
    Msgtext,
    RFC822Attribute
};
use command::command::Attribute::{
    Body,
    BodyPeek,
    BodySection,
    BodyStructure,
    Envelope,
    Flags,
    InternalDate,
    RFC822,
    UID
};
use command::command::BodySectionType::{
    AllSection,
    MsgtextSection,
    PartSection
};
use command::command::CommandType::Fetch;
use command::command::Msgtext::{
    HeaderMsgtext,
    HeaderFieldsMsgtext,
    HeaderFieldsNotMsgtext,
    TextMsgtext,
    MimeMsgtext
};
use command::command::RFC822Attribute::{
    AllRFC822,
    HeaderRFC822,
    SizeRFC822,
    TextRFC822
};
use command::sequence_set::SequenceItem;
use command::sequence_set::SequenceItem::{
    Number,
    Range,
    Wildcard
};

/* FETCH command rules */

#[export]
fetch -> Command
    = "FETCH"i SP set:sequence_set SP attrs:(
    "(" a:fetch_att b:(SP fetch_att)* ")"
    {
        let mut attrs = vec![a];
        for attr in b.into_iter() {
            attrs.push(attr);
        }
        attrs
    }
    / attr:fetch_att { vec![attr] }
    / "ALL"i { vec![Flags, InternalDate, RFC822(SizeRFC822), Envelope] }
    / "FULL"i { vec![Flags, InternalDate, RFC822(SizeRFC822), Envelope, Body] }
    / "FAST"i { vec![Flags, InternalDate, RFC822(SizeRFC822)] })
    { Command::new(Fetch, set, attrs) }

fetch_att -> Attribute
    = "ENVELOPE"i { Envelope }
    / "FLAGS"i { Flags }
    / "INTERNALDATE"i { InternalDate }
    / "RFC"i "822" sub_attr:(".HEADER" { HeaderRFC822 } / ".SIZE" { SizeRFC822 } / ".TEXT" { TextRFC822 })? { RFC822(sub_attr.unwrap_or(AllRFC822)) }
    / "UID"i { UID }
    / "BODY"i "." "PEEK"i section:section octets:("<" first_octet:number "." last_octet:nz_number ">" { (first_octet, last_octet) })? { BodyPeek(section, octets) }
    / "BODY"i section:section octets:("<" first_octet:number "." last_octet:nz_number ">" { (first_octet, last_octet) })? { BodySection(section, octets) }
    / "BODY"i sub_attr:("STRUCTURE" { BodyStructure })? { sub_attr.unwrap_or(Body) }

section -> BodySectionType
    = "[" section:(section_spec)? "]"
    { section.unwrap_or(AllSection) }

section_spec -> BodySectionType
    = a:section_msgtext { MsgtextSection(a) }
    / (a:section_part b:("." section_text)? { PartSection(a, b) })

section_msgtext -> Msgtext
    = "HEADER"i "." "FIELDS"i not:("." "NOT"i)? SP headers:header_list {
            match not {
                Some(_) => {
                    HeaderFieldsNotMsgtext(headers)
                },
                None => {
                    HeaderFieldsMsgtext(headers)
                }
            }
        }
    / "HEADER"i { HeaderMsgtext }
    / "TEXT"i { TextMsgtext }
    /* top-level or MESSAGE/RFC822 part */

header_list -> Vec<String>
    = "(" a:header_fld_name b:(SP header_fld_name)* ")"
    {
        let mut fields = vec![a];
        for field in b.into_iter() {
            fields.push(field);
        }
        fields
    }

header_fld_name -> String
    = a:astring
    { (&a[..]).to_ascii_uppercase().to_string() }

section_part -> Vec<usize>
    = a:nz_number b:("." nz_number)*
    {
        let mut parts = vec![a];
        for part in b.into_iter() {
            parts.push(part);
        }
        parts
    }
    /* body part nesting */

section_text -> Msgtext
    = section_msgtext / "MIME"i { MimeMsgtext }
    /* text other than actual body part (headers, etc.) */

astring -> String
    = (ASTRING_CHAR+ { match_str.to_string() }) / string

ASTRING_CHAR
    = ATOM_CHAR / resp_specials

ATOM_CHAR
    = (!atom_specials CHAR)
    /* any CHAR except atom_specials */

atom_specials
    = "(" / ")" / "{" / SP / CTL / list_wildcards
    / quoted_specials / resp_specials

CTL
    = [\x00-\x1F] / [\x7F]
    /* control characters */

list_wildcards
    = "%" / "*"

quoted_specials
    = DQUOTE / "\\"

resp_specials
    = "]"

string -> String
    = quoted / literal

quoted -> String
    = DQUOTE quoted_string:(QUOTED_CHAR* { match_str.to_string() }) DQUOTE
    { quoted_string }

literal -> String
    = "{" number "}" CRLF (CHAR8* { match_str.to_string() })
    /*
     * the "number" is used to indicate the number of octets.
     */

QUOTED_CHAR
    = (!quoted_specials TEXT_CHAR)
    / "\\" quoted_specials
    /* any TEXT_CHAR except quoted_specials */

TEXT_CHAR
    = (!eolChar CHAR)
    /* any CHAR except CR and LF */

/* SequenceItem and set rules */

#[export]
sequence_set -> Vec<SequenceItem>
    = a:(seq_range / seq_number) b:("," sequence_set)*
    {
        let mut seq = vec![a];
        for set in b.into_iter() {
            for elem in set.into_iter() {
                seq.push(elem);
            }
        };
        seq
    }

seq_range -> SequenceItem
    = a:seq_number ":" b:seq_number
    { Range(Box::new(a), Box::new(b)) }

seq_number -> SequenceItem
    = (num:nz_number { Number(num) }) / ("*" { Wildcard })

/* RFC 3501 BOILERPLATE */

number -> usize
    = u:(DIGIT+ { match_str.parse().unwrap() })
    { u }
    /*
     * unsigned 32-bit integer
     * (0 <= n < 4,294,967,296)
     */

nz_number -> usize
    = u:(digit_nz DIGIT* { match_str.parse().unwrap() })
    { u }
    /*
     * non-zero unsigned 32-bit integer
     * (0 < n < 4,294,967,296)
     */

digit_nz
    = [1-9]

DIGIT
    = [0-9]

CHAR
    = .
    /* any ASCII char */

CHAR8
    = (![\x00] CHAR)
    /* any octet except NUL, \x00 */

DQUOTE
    = "\""

SP
    = whitespace

CRLF
    = eol

/* PEG boilerplate from kevinmehall/rust-peg follows */

__ = (whitespace / eol / comment)*

/* Modeled after ECMA-262, 5th ed., 7.4. */
comment
    = singleLineComment
    / multiLineComment

singleLineComment
    = "//" (!eolChar .)*

multiLineComment
    = "/*" (!"*/" .)* "*/"

/* Modeled after ECMA-262, 5th ed., 7.3. */
eol
    = "\n"
    / "\r\n"
    / "\r"
    / "\u2028"
    / "\u2029"

eolChar
    = [\n\r\u2028\u2029]
    /* Modeled after ECMA-262, 5th ed., 7.2. */

whitespace
    = [ \t\u00A0\uFEFF\u1680\u180E\u2000-\u200A\u202F\u205F\u3000] // \v\f removed
