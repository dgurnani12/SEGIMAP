use parser::{All, Number, Range, SequenceItem};

/* FETCH command rules */

/* SequenceItem and set rules */

#[export]
sequence_set -> Vec<SequenceItem>
    = a:(seq_range / seq_number) b:("," sequence_set)*
    {
        let mut seq = vec![a];
        for set in b.into_iter() {
            for elem in set.into_iter() {
                seq.push(elem);
            }
        };
        seq
    }

seq_range -> SequenceItem
    = a:seq_number ":" b:seq_number
    { Range(box a, box b) }

seq_number -> SequenceItem
    = (num:nz_number { Number(num) }) / (all:"*" { All })

/* RFC 3501 BOILERPLATE */

number -> uint
    = u:(DIGIT+ { from_str::<uint>(match_str).unwrap() }) __
    { u }
    /*
     * unsigned 32-bit integer
     * (0 <= n < 4,294,967,296)
     */

nz_number -> uint
    = u:(digit_nz DIGIT* { from_str::<uint>(match_str).unwrap() }) __
    { u }
    /*
     * non-zero unsigned 32-bit integer
     * (0 < n < 4,294,967,296)
     */

digit_nz
    = [1-9]

DIGIT
    = [0-9]

CHAR
    = .
    /* any ASCII char */

CHAR8
    = (![\x00] CHAR)
    /* any octet except NUL, \x00 */

DQUOTE
    = "\""

SP
    = whitespace

CRLF
    = eol

/* PEG boilerplate from kevinmehall/rust-peg follows */

__ = (whitespace / eol / comment)*

/* Modeled after ECMA-262, 5th ed., 7.4. */
comment
    = singleLineComment
    / multiLineComment

singleLineComment
    = "//" (!eolChar .)*

multiLineComment
    = "/*" (!"*/" .)* "*/"

/* Modeled after ECMA-262, 5th ed., 7.3. */
eol
    = "\n"
    / "\r\n"
    / "\r"
    / "\u2028"
    / "\u2029"

eolChar
    = [\n\r\u2028\u2029]
    /* Modeled after ECMA-262, 5th ed., 7.2. */

whitespace
    = [ \t\u00A0\uFEFF\u1680\u180E\u2000-\u200A\u202F\u205F\u3000] // \v\f removed
